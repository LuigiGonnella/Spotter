// ✅ Riassunto N:N
// User <-> User (amicizie GymBro)
// User <-> GroupChat (partecipanti)
// Exercise <-> DailyWorkout (WorkoutExercise)
generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    url = env("DATABASE_URL")
}

model User {
    id Int @id @default(autoincrement())
    email String @unique
    passwordHash String? //opzionale per utenti OAuth
    role Role @default(USER)
    status_admin Status?
    provider String?
    providerId String?
    createdAt DateTime @default(now())
    refreshToken RefreshToken[]

    //campi profilo
    firstName String?
    lastName String?
    dateOfBirth DateTime?
    bio String?
    profileImage String? //URL

    isPublic Boolean @default(false)



    //sistema GymBros
    sentBuddyRequests GymBuddyRequest[] @relation("SentRequests")
    receivedBuddyRequests GymBuddyRequest[] @relation("ReceivedRequests")
    
    // Friendship system (many-to-many)
    gymBros GymBroFriendship[] @relation("User1")
    gymBrosOf GymBroFriendship[] @relation("User2")

    memberships UserGym[] //relazione con le iscrizioni in palestra
    workoutPlans WorkoutPlan[]
    createdWorkouts DailyWorkout[] @relation("CreatedWorkouts")

    // Records degli esercizi per ranking
    exerciseRecords ExerciseRecord[]
    recordValidationVotes RecordValidationVote[]


    @@map("users")
    LeaderboardRecord LeaderboardRecord[]
    PrivateMessage PrivateMessage[]
    privateChatsAsUser1 PrivateChat[] @relation("PrivateChatUser1")
    privateChatsAsUser2 PrivateChat[] @relation("PrivateChatUser2")
    GroupMessage GroupMessage[]
    GroupChatParticipant GroupChatParticipant[]
    GroupChat GroupChat[]
    Notification Notification[]
    adminGymId Int?
    Gym Gym? @relation("GymAdmin", fields: [adminGymId], references: [id])
}

model RefreshToken {
    id Int @id @default(autoincrement())
    jti String @unique //identificativo
    tokenHash String //contenuto hashato
    userId Int
    expiresAt DateTime
    revoked Boolean @default(false)
    createdAt DateTime @default(now())

    //relazioni
    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@map("refresh_tokens")
}

enum Role {
    USER
    ADMIN
    SUPER_ADMIN
}

//palestra
model Gym {
    id Int @id @default(autoincrement())
    name String 
    address String
    city String
    description String?
    email     String?
    verified  Boolean  @default(false) // palestra non attiva finché non verificata


    // Geolocalizzazione per discovery
    latitude Decimal?
    longitude Decimal?

    createdAt DateTime @default(now())

    admins    User[] @relation("GymAdmin")


    //relazioni
    members UserGym[]
    buddyRequests GymBuddyRequest[]
    exerciseRecords ExerciseRecord[] // Records interni alla palestra
    gymBroFriendships GymBroFriendship[]
    leaderboardRecords LeaderboardRecord[] // Opposite relation for LeaderboardRecord

    @@unique([name])
    @@map("gyms")
    GroupChat GroupChat[]
}

//user-gym
model UserGym {
    id Int @id @default(autoincrement())
    userId Int
    gymId Int
    joinedAt DateTime @default(now())
    isActive Status @default(PENDING)

    user User @relation(fields: [userId], references: [id], onDelete: Cascade)
    gym Gym @relation(fields: [gymId], references: [id], onDelete: Cascade)
    
    @@unique([userId, gymId])
}

model DailyWorkout { 
    id Int @id @default(autoincrement())
    title String
    description String?
    duration Int?
    createdAt DateTime @default(now())

    createdBy Int
    creator User @relation("CreatedWorkouts", fields: [createdBy], references: [id], onDelete: Cascade)

    workoutExercises WorkoutExercise[]

}

model WorkoutPlan {//utente crea una sua scheda e può renderla pubblica. Può anche scegliere un workout già pubblico
    id Int @id @default(autoincrement())
    name String 
    description String?
    isPublic Boolean  @default(false)//possiamo mostrare tutto lo storico delle schede pubbliche

    weekSchedule Json // { "monday": 1, "tuesday": null, "wednesday": 2, etc. }


    // Proprietario
    userId Int
    user User @relation(fields: [userId], references: [id], onDelete: Cascade)
    
    createdAt DateTime @default(now())
    likes Int @default(0) //mi piace degli utenti

    @@map("workout_plans")

}

model Exercise {
    id Int @id @default(autoincrement())
    name String
    description String?
    muscleGroup String

    workoutExercises WorkoutExercise[]
    exerciseRecords ExerciseRecord[] // Per leaderboard

    createdAt DateTime @default(now())
    isPublic Boolean @default(false)

    
    @@map("exercises")
    LeaderboardRecord LeaderboardRecord[]
}

// Tabella di collegamento Exercise <-> DailyWorkout
model WorkoutExercise {
    id Int @id @default(autoincrement())
    
    // Configurazione specifica per questo workout
    sets Int?
    reps String? // "8-12", "10", "AMRAP", etc.
    weight Decimal?
    restTime Int? // Secondi di riposo
    order Int // Ordine SPECIFICO per questo workout
    notes String?
    
    // Relazioni
    exerciseId Int
    dailyWorkoutId Int
    exercise Exercise @relation(fields: [exerciseId], references: [id], onDelete: Cascade)
    dailyWorkout DailyWorkout @relation(fields: [dailyWorkoutId], references: [id], onDelete: Cascade)
    
    // Ordine univoco per workout
    @@unique([dailyWorkoutId, order])
    
    @@map("workout_exercises")
}

// Sistema di richieste GymBro
model GymBuddyRequest {
    id Int @id @default(autoincrement())
    fromUserId Int
    toUserId Int
    gymId Int
    message String?
    status Status @default(PENDING) // "PENDING", "ACCEPTED", "DECLINED"
    
    // Relazioni
    fromUser User @relation("SentRequests", fields: [fromUserId], references: [id], onDelete: Cascade)
    toUser User @relation("ReceivedRequests", fields: [toUserId], references: [id], onDelete: Cascade)
    gym Gym @relation(fields: [gymId], references: [id], onDelete: Cascade)
    
    createdAt DateTime @default(now())
    
    @@unique([fromUserId, toUserId, gymId]) // Una richiesta per coppia per palestra
    @@map("gym_buddy_requests")
}

enum Status {
    PENDING
    ACCEPTED
    DECLINED
}

// Tabella di amicizia GymBros (bidirezionale)
model GymBroFriendship {
    id Int @id @default(autoincrement())
    user1Id Int
    user2Id Int
    gymId Int // In quale palestra sono diventati bros
    
    // Relazioni
    user1 User @relation("User1", fields: [user1Id], references: [id], onDelete: Cascade)
    user2 User @relation("User2", fields: [user2Id], references: [id], onDelete: Cascade)
    gym Gym @relation(fields: [gymId], references: [id], onDelete: Cascade)
    
    becameFriendsAt DateTime @default(now())
    
    // Amicizia unica per palestra
    @@unique([user1Id, user2Id, gymId])
    @@map("gym_bro_friendships")
}

// Records degli esercizi (interni alla palestra), solo PR dell'utente, sia per ranking personale, sia per ranking pubblico nella palestra
model ExerciseRecord {
    id Int @id @default(autoincrement())
    userId Int
    exerciseId Int
    gymId Int
    
    // Dati del record
    weight Decimal
    reps Int
    notes String?
    
    // Tracking
    recordDate DateTime @default(now())
    status    RecordStatus @default(UNVERIFIED) // stato base

    
    // Relazioni
    user User @relation(fields: [userId], references: [id], onDelete: Cascade)
    exercise Exercise @relation(fields: [exerciseId], references: [id], onDelete: Cascade)
    gym Gym @relation(fields: [gymId], references: [id], onDelete: Cascade)

    validationVotes RecordValidationVote[] // voti della community, VUOTI se record è OFFICIAL


    @@unique([userId, gymId, exerciseId])
    @@map("exercise_records")
    LeaderboardRecord LeaderboardRecord[]
}

enum RecordStatus {
  UNVERIFIED   // record privato personale e per classifica libera da validazione
  OFFICIAL     // validato da admin palestra
}

// Voti degli utenti sui record
model RecordValidationVote {
  id        Int      @id @default(autoincrement())
  recordId  Int
  userId    Int

  createdAt DateTime @default(now())

  record ExerciseRecord @relation(fields: [recordId], references: [id], onDelete: Cascade)
  user   User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([recordId, userId]) // un solo voto per utente per record
}

// Leaderboard ufficiale (scelta dagli admin)
model LeaderboardRecord {
  id        Int      @id @default(autoincrement())
  gymId     Int
  exerciseId Int
  recordId  Int      // riferimento al record ufficiale scelto, deve essere sempre "OFFICIAL"
  createdAt DateTime @default(now())
  createdBy Int      // admin che ha inserito

  gym      Gym      @relation(fields: [gymId], references: [id], onDelete: Cascade)
  exercise Exercise @relation(fields: [exerciseId], references: [id], onDelete: Cascade)
  record   ExerciseRecord @relation(fields: [recordId], references: [id], onDelete: Cascade)
  admin    User     @relation(fields: [createdBy], references: [id], onDelete: Cascade)

  @@unique([gymId, exerciseId]) // solo un record ufficiale per esercizio per palestra
  @@map("leaderboard_records")
}

model PrivateChat {
  id        Int      @id @default(autoincrement())
  user1Id   Int
  user2Id   Int
  createdAt DateTime @default(now())

  user1 User @relation("PrivateChatUser1", fields: [user1Id], references: [id], onDelete: Cascade)
  user2 User @relation("PrivateChatUser2", fields: [user2Id], references: [id], onDelete: Cascade)
  messages PrivateMessage[]

  @@unique([user1Id, user2Id])
  @@index([user1Id])
  @@index([user2Id])
  @@map("private_chats")
}

model PrivateMessage {
  id        Int      @id @default(autoincrement())
  chatId    Int
  senderId  Int
  content   String
  sentAt    DateTime @default(now())
  read      Boolean  @default(false)

  chat   PrivateChat @relation(fields: [chatId], references: [id], onDelete: Cascade)
  sender User        @relation(fields: [senderId], references: [id], onDelete: Cascade)

  @@index([chatId, sentAt]) // query veloce dei messaggi recenti, sfruttata in automatico da prisma
  @@index([senderId])
  @@map("private_messages")
}

model GroupChat {
  id        Int      @id @default(autoincrement())
  name      String
  gymId     Int?     
  createdBy Int
  createdAt DateTime @default(now())

  creator User        @relation(fields: [createdBy], references: [id], onDelete: Cascade)
  gym     Gym?        @relation(fields: [gymId], references: [id], onDelete: Cascade)
  participants GroupChatParticipant[]
  messages GroupMessage[]

  @@index([gymId])
  @@map("group_chats")
}

model GroupChatParticipant {
  id         Int      @id @default(autoincrement())
  chatId     Int
  userId     Int
  joinedAt   DateTime @default(now())
  isAdmin    Boolean  @default(false)

  chat GroupChat @relation(fields: [chatId], references: [id], onDelete: Cascade)
  user User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([chatId, userId])
  @@index([userId])      // per trovare velocemente tutte le chat di un utente
  @@map("group_chat_participants")
}

model GroupMessage {
  id        Int      @id @default(autoincrement())
  chatId    Int
  senderId  Int
  content   String
  sentAt    DateTime @default(now())
  readBy    Json?    // array di userId che hanno letto il messaggio

  chat   GroupChat @relation(fields: [chatId], references: [id], onDelete: Cascade)
  sender User      @relation(fields: [senderId], references: [id], onDelete: Cascade)

  @@index([chatId, sentAt]) // messaggi recenti per chat
  @@index([senderId])
  @@map("group_messages")
}

enum NotificationType {
  PRIVATE_MESSAGE
  GROUP_MESSAGE
  FRIEND_REQUEST
  FRIEND_ACCEPTED
  LEADERBOARD_UPDATE
}

model Notification {
  id        Int      @id @default(autoincrement())
  userId    Int
  type      NotificationType
  payload   Json     // metadati sicuri (es: chatId, senderId, messageId, preview opzionale lato client)
  read      Boolean  @default(false)
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, read, createdAt])
  @@map("notifications")
}
